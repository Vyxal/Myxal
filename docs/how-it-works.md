# How Myxal Works

Here I'll get the reveal all the intricacies of the Myxal compiler and what I learned from this project.

## Parsing

Obviously you cannot get very far in creating a programming language without parsing it. Unlike its parent
language [Vyxal](https://github.com/Vyxal/Vyxal), Myxal does not use a custom lexer/parser. Using a custom parsing
system allows for a lot of random parsing quirks, like the inability of Vyxal to parse the single byte backslash
character. Instead, the grammar is written out in [ANTLR](https://www.antlr.org) form.

The [lexer](https://github.com/Vyxal/Myxal/blob/main/app/src/main/antlr/MyxalLexer.g4) may appear to be slightly more
complicated than it should be (and it probably is, even with two rewrites), but it is relatively simple once you read
it. It starts out by defining basic element features: prefixes, alias separators, special elements, modifiers, digits.
It is here in the lexer that comments are captured and immediately thrown away, like they were never there. Then
alphabetic characters are captured, and then whitespace. After swallowing lambdas and variables, the lexer gets to
strings. Initially, strings were defined in the parser, until that wreaked havoc with precedence of tokens. After that,
the random syntax elements that deal with various structures are lexed. Finally, the very last
token, `LITERALLY_ANY_TEXT`, captures anything and everything else. This is the token used for elements.

The [parser](https://github.com/Vyxal/Myxal/blob/main/app/src/main/antlr/MyxalParser.g4) is relatively simple: first
come alias definitions, then the program. Each structure gets its own dedicated node. Almost. There is a `fori_loop`
node that is simply a normal `for_loop`, but with nine digits prepended to it. The nine digits are the highest power of
ten that a 32-bit number can definitely store. This pattern, when verified through the AST transformer, can be converted
into the target implementation as a simple counting `for` loop, instead of a complex big number object and the iterator
to it.

## Transformation

Jyxal, the precursor of Myxal, used to compile code directly from the ANTLR AST generated. However, then the decision to
create a multi-targeted compiler came, I realized that there was simply too much special-purpose compilation code. That
code would be duplicated across all the different implementations of Myxal. For example, a `fori_loop` is usually
compiled to a counter loop, unless it contains the `CONTEXT_VAR` token, in which case it is identical to a `for_loop`.

To spare the compilers from dealing with the pain of constant handling of edge cases, there is
a [Transformer](https://github.com/Vyxal/Myxal/blob/main/app/src/main/kotlin/io/github/seggan/myxal/app/Transformer.kt)
class that converts the AST generated by ANTLR into a
custom [Myxal AST](https://github.com/Vyxal/Myxal/tree/main/compiler/src/main/kotlin/io/github/seggan/myxal/compiler/tree)
. The transformer applies things like putting a definite split in the `for[i]_loop` problem, giving specialty elements
their own nodes, applying aliases, expanding modifiers, and unifying the lambda types. Importantly, it also applies
the [standard library](#Standard-Library) onto the code. The result of all this transformation is a vastly simplified
AST without a zillion edge cases.

## Standard Library

Unlike (almost?) every other golfing language, Myxal has
a [standard library](https://github.com/Vyxal/Myxal/blob/main/compiler/src/main/resources/stdlib.myx) that is applied
at [transformation](#Transformation). The library is a key part of the multitargeting of Myxal; it defines elements as
groups of other elements, making the workload for adding a new target much lighter. The library contains all the
constants available, saving the work of redefining them for each implementation. The file itself is just a bunch of
aliases. During transformation, the aliased elements are replaced by their equivalents. Therefore, the end result is
not `kS`, it is `"à¶ž"`. Some elements are also implemented as others. For example, boolify can be `[1|0]`. However, the
reason many more are not implemented is because of overloads. One overload implemented as a group of elements may do
something completely different on a different data type.