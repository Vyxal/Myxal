# How Myxal Works

Here I'll get the reveal all the intricacies of the Myxal compiler and what I learned from this project.

## Parsing

Obviously you cannot get very far in creating a programming language without parsing it. Unlike its parent
language [Vyxal](https://github.com/Vyxal/Vyxal), Myxal does not use a custom lexer/parser. Using a custom parsing
system allows for a lot of random parsing quirks. Instead, the grammar is written out in [ANTLR](https://www.antlr.org)
form.

The [lexer](https://github.com/Vyxal/Myxal/blob/main/app/src/main/antlr/MyxalLexer.g4) may appear to be slightly more
complicated than it should be (and it probably is, even with two rewrites), but it is relatively simple once you read
it. It starts out by defining basic element features: prefixes, alias separators, special elements, modifiers, digits.
It is here in the lexer that comments are captured and immediately thrown away, like they were never there. Then
alphabetic characters are captured, and then whitespace. After swallowing lambdas and variables, the lexer gets to
strings. Initially, strings were defined in the parser, until that wreaked havoc with precedence of tokens. After that,
the random syntax elements that deal with various structures are lexed. Finally, the very last
token, `LITERALLY_ANY_TEXT`, captures anything and everything else. This is the token used for elements.

The [parser](https://github.com/Vyxal/Myxal/blob/main/app/src/main/antlr/MyxalParser.g4) is relatively simple: first
come alias definitions, then the program. Each structure gets its own dedicated node. Almost. There is a `fori_loop`
node that is simply a normal `for_loop`, but with nine digits prepended to it. The nine digits are the highest power of
ten that a 32-bit number can definitely store. This pattern, when verified through the AST transformer, can be converted
into the target implementation as a simple counting `for` loop, instead of a complex big number object and the iterator
to it.

## Transformation

Jyxal, the precursor of Myxal, used to compile code directly from the ANTLR AST generated. However, then the decision to
create a multi-targeted compiler came, I realized that there was simply too much special-purpose compilation code. That
code would be duplicated across all the different implementations of Myxal. For example, a `fori_loop` is usually
compiled to a counter loop, unless it contains the `CONTEXT_VAR` token, in which case it is identical to a `for_loop`.

To spare the compilers from dealing with the pain of constant handling of edge cases, there is
a [Transformer](https://github.com/Vyxal/Myxal/blob/main/app/src/main/kotlin/io/github/seggan/myxal/app/Transformer.kt)
class that converts the AST generated by ANTLR into a
custom [Myxal AST](https://github.com/Vyxal/Myxal/tree/main/compiler/src/main/kotlin/io/github/seggan/myxal/compiler/tree)
. The transformer applies things like putting a definite split in the `for[i]_loop` problem, giving specialty elements
their own nodes, applying aliases, expanding modifiers, and unifying the lambda types. Importantly, it also applies
the [standard library](#Standard-Library) onto the code. The result of all this transformation is a vastly simplified
AST without a zillion edge cases.

## Standard Library

Unlike (almost?) every other golfing language, Myxal has
a [standard library](https://github.com/Vyxal/Myxal/blob/main/compiler/src/main/resources/stdlib.myx) that is applied
at [transformation](#Transformation). The library is a key part of the multitargeting of Myxal; it defines elements as
groups of other elements, making the workload for adding a new target much lighter. The library contains all the
constants available, saving the work of redefining them for each implementation. The file itself is just a bunch of
aliases. During transformation, the aliased elements are replaced by their equivalents. Therefore, the end result is
not `kS`, it is `"à¶ž"`. Some elements are also implemented as others. For example, boolify can be `[1|0]`. However, the
reason many more are not implemented is because of overloads. One overload implemented as a group of elements may do
something completely different on a different data type.

## JVM Compilation

Now we get to the juicy stuff. This section will specifically be about JVM compilation. The next section will be about
native.

### Structures

The basic structures of Myxal are implemented in the way you expect. `if` statements are implemented as a `truthValue` (
boolify) call followed by an `IFEQ` jump to the end of the statement (`runtime/` corresponds
to `io/github/seggan/myxal/runtime/`):

```
INVOKEVIRTUAL runtime/ProgramStack.pop()Ljava/lang/Object;
INVOKESTATIC runtime/RuntimeHelpers.truthValue(Ljava/lang/Object;)Z
IFEQ end
... // Do stuff
end:
... // Post-if
```

If the `if` has an `else` clause, you get:

```
INVOKEVIRTUAL runtime/ProgramStack.pop()Ljava/lang/Object;
INVOKESTATIC runtime/RuntimeHelpers.truthValue(Ljava/lang/Object;)Z
IFEQ else
... // If clause
GOTO end
else:
... // Else clause
end:
... // Post-if
```

Standard while loops are implemented as such:

```
start:
... // Condition
INVOKEVIRTUAL runtime/ProgramStack.pop()Ljava/lang/Object;
INVOKESTATIC runtime/RuntimeHelpers.truthValue(Ljava/lang/Object;)Z
IFEQ end
... // While body
GOTO start
end:
... // Post-while
```

While infinite loops use a single `GOTO`:

```
start:
... // While body
GOTO start
```

Good ol' `for` loops use iterators, just like Java's for-each loops:

```
INVOKEVIRTUAL runtime/ProgramStack.pop()Ljava/lang/Object;
INVOKESTATIC runtime/RuntimeHelpers.forify(Ljava/lang/Object;)Ljava/util/Iterator;
ASTORE iterator
start:
ALOAD iterator
INVOKEINTERFACE java/util/Iterator.hasNext()Z
IFEQ end
ALOAD iterator
INVOKEINTERFACE java/util/Iterator.next()Ljava/lang/Object;
ALOAD stack
SWAP
INVOKEVIRTUAL runtime/ProgramStack.push(Ljava/lang/Object;)V
... // For body
GOTO start
end:
... // Post-for
```

To improve performance, counting `for` loops use a countdown:

```
ISTORE count
start:
IINC count -1
ILOAD count
IFEQ end
... // For body
GOTO start
end:
... // Post-for
```

### Lambdas

A lambda is simply a function called `lambda$counter`. To have an instance of this function on the stack, Myxal first
pushes a `MethodHandle` on the JVM stack (thanks for letting us do that, Oracle :heart: ), then wraps it with the arity
into a `Lambda` object. That is then pushed onto the stack.

### Register and Variables

The register and variables are implemented as `private static Object`s in the main class. Coincidentally, this also
means that you can get the register's value by simply accessing the variable named `register`.

### Elements

And who can forget about the elements? Elements each have a unique name based on
their [enum constant name](https://github.com/Vyxal/Myxal/blob/main/compiler/src/main/kotlin/io/github/seggan/myxal/compiler/Element.kt)
, converted to camel case. Monads take a single object as a parameter and return the result. This allows effective
inlining. Dyads take the stack and return an object. Anything else (or elements that return more than one value) take
the stack and return nothing.